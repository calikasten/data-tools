<!DOCTYPE html>
<html>
<head>
    <title>CSV diff</title>
    <style>
        * { box-sizing: border-box; }

        body {
            border: 1px solid #ccc;
            min-height: 600px;
            font-family: tahoma, arial;
            font-size: 12px;
            overflow: auto;
            min-width: 768px;
            padding: 5px;
        }

        a { color: #006ef1; }
        a:hover { color: crimson; }

        .drag-over { background: lightgreen; }

        #table {
            display: flex;
        }

        .stats + .stats {
            border-left: 2px solid #ccc;
            margin-left: 5px;
            padding-left: 5px;
        }

        tr:nth-child(2n) {
            background-color: lightblue;
        }
    </style>
</head>
<body
    ondragover="event.preventDefault(); this.classList.add('drag-over');"
    ondragstart="event.preventDefault()"
    ondragenter="event.preventDefault()"
    ondragend="event.preventDefault(); this.classList.remove('drag-over')"
    ondragleave="event.preventDefault(); this.classList.remove('drag-over')"
    ondrop="handleDrop(event); this.classList.remove('drag-over')"
>

    <h3 id='description'>Drag and Drop 2 CSVs Files.</h3>

    <div id="table-filter"></div>
    <h1 id="title"></h1>
    <div id="table"></div>

    <script>
        'use strict';

        const NULL_VALUE = '__blank__';
        const KEY_PREFERENCE = ['_id', 'upc', 'plu', 'slug', 'name'];

        let data = null;

        const init = () => {
            $('#description').innerHTML += `<div>Column preference order: ${KEY_PREFERENCE.join(', ')}</div>`;
        }

        const handleDrop = event => {
            event.preventDefault();
            if (!event.dataTransfer || !event.dataTransfer.files) return;
            const [file1, file2] = event.dataTransfer.files;
            if (!file1 || !file2) return alert('Expected 2 files to be dropped at once');

            Promise.all([
                parseCSVFile(file1),
                parseCSVFile(file2),
            ])
            .then(([csv1, csv2]) => {
                let key = null;
                const check = str => {
                    if (key) return;
                    if (!csv1.header.includes(str) || !csv2.header.includes(str)) return;
                    key = str;
                };
                KEY_PREFERENCE.forEach(check);
                if (!key) return alert('Invalid header, make sure you have at least a column named: _id, slug or name');

                render(key, [
                    csvDiff({key}, csv1, csv2),
                    csvDiff({key}, csv2, csv1),
                ]);
            });
        }

        const parseCSVFile = file => new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = ({target: {result}}) => {
                const csv = parseCSV(result);
                if (!csv || !csv.length || csv.length < 2) return reject('The given CSV is empty: ' + file.name);
                const header = Object.keys(csv[0]);
                resolve({
                    data: csv,
                    header,
                    name: file.name,
                    size: csv.length,
                });
            }
            reader.readAsText(file);
        });

        const makeMap = (arr, getKey) => {
            getKey = getKey || (x => x);
            const result = {};
            for (let obj of arr) result[getKey(obj)] = true;
            return result;
        }

        const csvDiff = ({key}, csv1, csv2) => {
            const getID = obj => obj[key] == null ? NULL_VALUE : obj[key];

            const data1Map = makeMap(csv1.data, getID);
            const header1Map = makeMap(csv1.header);

            const data2Map = makeMap(csv2.data, getID);
            const header2Map = makeMap(csv2.header);

            const missing = [];
            const common = [];
            for (let index = 0; index < csv1.data.length; ++index) {
                const obj = csv1.data[index];
                const id = getID(obj);
                if (data2Map[id]) {
                    common.push(Object.assign({}, obj, {'row #': index + 1}));
                    continue;
                }
                missing.push(Object.assign({}, obj, {'row #': index + 1}));
            }
            return Object.assign({}, csv1, {key, missing, common});
        }

        const render = (key, arr) => {
            $('#title').innerHTML = `Comparing based on the <b style="color:red">${key}</b> column`;
            $('#table').innerHTML = row(arr, obj => Templates.diffStats(obj));
        }

        const makeList = str => str.split('\n').map(s => s.trim());

        const $ = sel => document.querySelector(sel);
        const $$ = sel => Array.from(document.querySelectorAll(sel));

        const _downloadCache = [];
        const getDonwloadCSV = (type, name, header, list) => {
            const index = _downloadCache.length;
            _downloadCache.push({
                name: name.replace(/\.[^.]+$/, '') + `-${type}.csv`,
                header,
                list,
            });
            return `let d = _downloadCache[${index}]; downloadCSV(d.name, d.header, d.list);`;
        }

        const row = (arr, fn) => arr.map(fn).join('');
        const Templates = {
            diffStats: ({name, header, data, missing, common}) => `
                <div class="stats">
                    <h3>${name} (${data.length} rows)</h3>
                    <div>
                        ${missing.length} missing from the other file
                        <a href="javascript:void(0)" onclick="${getDonwloadCSV('missing', name, header, missing)}">(download missing)</a>
                    </div>
                    <div>
                        ${common.length} common with the other file
                        <a href="javascript:void(0)" onclick="${getDonwloadCSV('common', name, header, common)}">(download common)</a>
                    </div>
                    ${Templates.table(['row #'].concat(header), missing)}
                </div>
            `,

            table: (header, csv) => `
                <table cellspacing="0" cellpadding="0">
                    <thead>
                        <tr>${row(header, key => `<th>${key}</th>`)}</tr>
                    </thead>
                    <tbody>
                        ${row(csv, obj => `<tr class="row">
                            ${row(header, key => `<td>${obj[key] == null ? '' : obj[key]}</td>`)}
                        </tr>`)}
                    </tbody>
                </table>
            `,
        };

        const downloadCSV = (name, header, data) => {
            const getCSV = (header, arr) => {
                const stringify = str => '"' + (str == null ? '' : str).toString().replace(/"/g, '""') + '"'
                const makeRow = val => header.map(key => stringify(val[key])).join(',')
                const headerObj = {}
                header.forEach(key => { headerObj[key] = key })
                return [makeRow(headerObj)].concat(arr.map(makeRow)).join('\n')
            }
            return downloadBlob(name, 'text/csv', getCSV(header, data));
        }

        const downloadBlob = (fileName, mimeType, data) => {
            const blob = new Blob([data], {type: mimeType});
            const url = window.URL.createObjectURL(blob);
            downloadURL(url, fileName, mimeType);
            setTimeout(() => window.URL.revokeObjectURL(url), 1000);
        };

        const downloadURL = (data, fileName) => {
            const a = document.createElement('a');
            a.href = data;
            a.download = fileName;
            document.body.appendChild(a);
            a.style = 'display: none';
            a.click();
            a.remove();
        };

        const parseCSV = str => {
            str = (str || '').trim();

            const csvToArray = (strData, strDelimiter) => {
                strDelimiter = (strDelimiter || ",");
                var objPattern = new RegExp(
                    (
                        "(\\" + strDelimiter + "|\\r?\\n|\\r|^)" +
                        "(?:\"([^\"]*(?:\"\"[^\"]*)*)\"|" +
                        "([^\"\\" + strDelimiter + "\\r\\n]*))"
                    ),
                    "gi"
                );

                var arrData = [[]];
                var arrMatches = null;

                while (arrMatches = objPattern.exec( strData )){
                    var strMatchedDelimiter = arrMatches[ 1 ];
                    if (
                        strMatchedDelimiter.length &&
                        strMatchedDelimiter !== strDelimiter
                        ){
                        arrData.push( [] );

                    }

                    var strMatchedValue;
                    if (arrMatches[ 2 ]){
                        strMatchedValue = arrMatches[ 2 ].replace(
                            new RegExp( "\"\"", "g" ),
                            "\""
                            );

                    } else {
                        strMatchedValue = arrMatches[ 3 ];

                    }

                    arrData[ arrData.length - 1 ].push( strMatchedValue );
                }
                return( arrData );
            }

            const data = csvToArray(str);
            const result = [];
            for (let index = 1; index < data.length; ++index) {
                const obj = {};
                for (let headerIndex = 0; headerIndex < data[0].length; ++headerIndex) {
                    const header = data[0][headerIndex].toLowerCase();
                     obj[header] = data[index][headerIndex];
                }
                result.push(obj);
            }
            return result;
        }

        init();
    </script>

</body>
</html>
