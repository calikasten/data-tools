<!DOCTYPE html>
<html>
<head>
    <title>CSV Parser</title>
    <style>
        * { box-sizing: border-box; }

        body {
            border: 1px solid #ccc;
            min-height: 600px;
            font-family: tahoma, arial;
            font-size: 12px;
        }

        a { color: #006ef1; }
        a:hover { color: crimson; }

        .drag-over { background: lightgreen; }

        .filter-list {
            display: flex;
            align-items: stretch;
            border-bottom: 2px solid #ccc;
            margin: 10px;
            max-height: 400px;
            overflow: auto;
        }

        .filter-values {
            display: flex;
            flex-direction: column;
        }

        .filter-values + .filter-values {
            margin-left: 10px;
        }

        .filtered {
            text-decoration: line-through;
            color: #666;
        }
    </style>
</head>
<body
    ondragover="event.preventDefault(); this.classList.add('drag-over');"
    ondragstart="event.preventDefault()"
    ondragenter="event.preventDefault()"
    ondragend="event.preventDefault(); this.classList.remove('drag-over')"
    ondragleave="event.preventDefault(); this.classList.remove('drag-over')"
    ondrop="handleDrop(event); this.classList.remove('drag-over')"
>

    <h3>Drop a CSV somewhere</h3>

    <div id="table-filter"></div>
    <div id="table"></div>

    <script>
        'use strict';

        const NULL_VALUE = '__blank__';
        const options = {
            clearDuplicates: true,
        };

        let data = null;

        const init = () => {}

        const handleDrop = event => {
            event.preventDefault();
            if (!event.dataTransfer || !event.dataTransfer.files) return;
            const [file] = event.dataTransfer.files;
            $('head title').innerHTML = 'CSV: ' + file.name;
            if (!file) return;
            const reader = new FileReader();
            reader.onload = ({target: {result}}) => {
                const csv = parseCSV(result);
                if (!csv || !csv.length || csv.length < 2) return errorHandler('The given CSV is empty');
                const header = Object.keys(csv[0]);
                data = {
                    name: file.name.replace(/\.[^.]+$/, '') + '-filtered.csv',
                    csv,
                    header,
                    csvFiltered: csv,
                    filters: header.reduce((obj, key) => Object.assign(obj, {[key]: ''}), {}),
                    filterOptions: computeFilterOptions(header, csv),
                };
                updateFilters();
                render();

            }
            reader.readAsText(file);
        }

        const updateFilterText = (key, value) => {
            if (data.filters[key] === value) return;
            data.filters[key] = makeList(value).map(str => str.toLowerCase()).join('\n').trim();
            updateFilters();
            renderTable();
        }

        const makeList = str => str.split('\n').map(s => s.trim());

        const escapeRegExp = str => str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');

        const toggleFilter = (key, value) => {
            let filterList = makeList(data.filters[key]);
            const isFiltered = filterList.indexOf(value) === -1;
            if (isFiltered) filterList = [value].concat(filterList);
            else filterList = filterList.filter(str => str !== value);
            data.filters[key] = filterList.join('\n').trim();

            updateFilters();
            renderTable();
            $$(`[data-key="${key}"][data-value="${value}"]`).forEach(elem => elem.classList.toggle('filtered', isFiltered));
            $(`textarea[data-filter="${key}"]`).value = data.filters[key];
        }

        const computeFilterOptions = (header, csv) => {
            const result = {};
            for (let key of header) {
                const map = {};
                for (let obj of csv) {
                    obj['__filter_' + key] = (obj[key] || '').split(/[,;]/).map(val => {
                        if (val == null || val === '') val = NULL_VALUE;
                        val = ('' + val).trim().toLowerCase();
                        map[val] = map[val] || 0;
                        ++map[val];
                        return val;
                    });
                }
                result[key] = Object.keys(map)
                    .map(value => ({value, count: map[value]}))
                    .filter(({count}) => count > 1)
                    .sort((a, b) => b.count - a.count);
            }
            return result;
        }

        const updateFilters = () => {
            const allFilters = Object.keys(data.filters).filter(key => !!data.filters[key]).map(key => {
                const list = makeList(data.filters[key]);
                const isReg = str => str[0] === '/' && str[str.length - 1] === '/';
                const strList = list.filter(str => !isReg(str));

                let reg = null;
                const regList = list.filter(isReg).map(str => str.slice(1, -1), 'i').map(str => str.trim()).filter(str => !!str).map(escapeRegExp);
                if (regList.length) reg = new RegExp('\\b(' + regList.join('|') + ')\\b', 'i');

                return [key, strList, reg];
            });

            const toFilter = data.csv;
            for (let obj of toFilter) delete obj.__filtered;

            if (options.clearDuplicates && data.header.indexOf('upc') >= 0) {
                const map = {};
                for (let obj of toFilter) {
                    map[obj.upc] = map[obj.upc] || [];
                    map[obj.upc].push(obj);
                }
                const duplicates = Object.keys(map).filter(upc => map[upc].length > 1);
                console.info(`%d duplicate upcs`, duplicates.length);
                duplicates.forEach(upc => {
                    let hit = false;
                    for (let obj of map[upc]) {
                        if (!hit && obj.brand) hit = true;
                        else obj.__filtered = true;
                    }
                    if (!hit) delete map[upc][0].__filtered;
                });
            }

            top: for (let obj of toFilter) {
                if (obj.__filtered) continue;
                for (let [key, list, reg] of allFilters) {
                    for (let filterVal of obj['__filter_' + key]) {
                        if (reg && reg.test(filterVal)) {
                            obj.__filtered = true;
                            continue top;
                        }
                        for (let filter of list) {
                            if (filterVal !== filter) continue;
                            obj.__filtered = true;
                            continue top;
                        }
                    }
                }
            }
            data.csvFiltered = toFilter.filter(obj => !obj.__filtered);
        }

        const render = () => {
            renderTable();
            $('#table-filter').innerHTML = Templates.filter(data.header, data.filterOptions);
        }
        const renderTable = () => $('#table').innerHTML = Templates.table(data.header, data.csvFiltered);

        const handleCopy = key => {
            const fn = e => {
                e.preventDefault();
                const clip = data.csvFiltered.map(x => x[key]).join('\n');
                if (e.clipboardData) {
                    e.clipboardData.setData('text/plain', clip);
                } else if (window.clipboardData) {
                    window.clipboardData.setData('Text', clip);
                }
            };

            window.addEventListener('copy', fn);
            document.execCommand('copy');
            window.removeEventListener('copy', fn);
        }

        const $ = sel => document.querySelector(sel);
        const $$ = sel => Array.from(document.querySelectorAll(sel));

        const row = (arr, fn) => arr.map(fn).join('');
        const Templates = {
            table: (header, csv) => `
                <h4>
                    ${csv.length} items (out of ${data.csv.length} total)
                    <button onclick="downloadCSV(data.name, data.header, data.csvFiltered)">Download!</button>
                    Duplicates are automagically filtered out based on a column named "upc". Preference will be given if the row has a value in the "brand" column.
                </h4>
                <table>
                    <thead>
                        <tr>${row(header, key => `<th>${key}<br /><button onClick="handleCopy('${key}')">copy</button></th>`)}</tr>
                    </thead>
                    <tbody>
                        ${row(csv, obj => `<tr class="row">
                            ${row(header, key => `<td>${obj[key] == null ? '' : obj[key]}</td>`)}
                        </tr>`)}
                    </tbody>
                </table>
            `,

            filter: (header, filterMap) => {
                let tabIndex = 0;
                return `
                <div class="filter-list">
                    ${row(header, key => `
                        <div class="filter">
                            <h3>${key}</h3>
                            <div class="filter-values">
                                <textarea
                                    data-filter="${key}"
                                    rows="4"
                                    placeholder="One per line"
                                    onblur="updateFilterText('${key}', event.target.value)"
                                    tabindex="${++tabIndex}"
                                ></textarea>
                                ${row(filterMap[key], ({value, count}) =>
                                    `<a
                                        href="javascript:void(0)"
                                        class="filter"
                                        onclick="toggleFilter('${key}', '${value.replace(/'/g, "\\'")}')"
                                        data-key="${key}"
                                        data-value="${value}"
                                    >${value} - ${count}</a>`
                                )}
                            </div>
                        </div>
                    `)}
                </div>
                `;
            },
        };

        const downloadCSV = (name, header, data) => {
            const getCSV = (header, arr) => {
                const stringify = str => '"' + (str == null ? '' : str).toString().replace(/"/g, '""') + '"'
                const makeRow = val => header.map(key => stringify(val[key])).join(',')
                const headerObj = {}
                header.forEach(key => { headerObj[key] = key })
                return [makeRow(headerObj)].concat(arr.map(makeRow)).join('\n')
            }
            return downloadBlob(name, 'text/csv', getCSV(header, data));
        }

        const downloadBlob = (fileName, mimeType, data) => {
            const blob = new Blob([data], {type: mimeType});
            const url = window.URL.createObjectURL(blob);
            downloadURL(url, fileName, mimeType);
            setTimeout(() => window.URL.revokeObjectURL(url), 1000);
        };

        const downloadURL = (data, fileName) => {
            const a = document.createElement('a');
            a.href = data;
            a.download = fileName;
            document.body.appendChild(a);
            a.style = 'display: none';
            a.click();
            a.remove();
        };

        const parseCSV = str => {
            str = (str || '').trim();

            const cleanReg = /[^a-z0-9\s,;-_]/gi;

            const csvToArray = (strData, strDelimiter) => {
                strDelimiter = (strDelimiter || ",");
                var objPattern = new RegExp(
                    (
                        "(\\" + strDelimiter + "|\\r?\\n|\\r|^)" +
                        "(?:\"([^\"]*(?:\"\"[^\"]*)*)\"|" +
                        "([^\"\\" + strDelimiter + "\\r\\n]*))"
                    ),
                    "gi"
                );

                var arrData = [[]];
                var arrMatches = null;

                while (arrMatches = objPattern.exec( strData )){
                    var strMatchedDelimiter = arrMatches[ 1 ];
                    if (
                        strMatchedDelimiter.length &&
                        strMatchedDelimiter !== strDelimiter
                        ){
                        arrData.push( [] );

                    }

                    var strMatchedValue;
                    if (arrMatches[ 2 ]){
                        strMatchedValue = arrMatches[ 2 ].replace(
                            new RegExp( "\"\"", "g" ),
                            "\""
                            );

                    } else {
                        strMatchedValue = arrMatches[ 3 ];

                    }

                    arrData[ arrData.length - 1 ].push( strMatchedValue );
                }
                return( arrData );
            }

            const data = csvToArray(str);
            const result = [];
            for (let index = 1; index < data.length; ++index) {
                const obj = {};
                for (let headerIndex = 0; headerIndex < data[0].length; ++headerIndex) {
                    const header = data[0][headerIndex].toLowerCase().replace(cleanReg, '');
                     obj[header] = data[index][headerIndex];
                }
                result.push(obj);
            }
            return result;
        }

        init();
    </script>

</body>
</html>
